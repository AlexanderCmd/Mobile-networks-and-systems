function [PeBit, PED, T] = model(k, gX, codes, sigma, N)
%                1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6-7 8 9 0 1
matrixHammingEnc = [1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0; % 1
                 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0; % 2
                 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0; % 3
                 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0; % 4
                 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0; % 5
                 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0; % 6
                 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0; % 7
                 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0; % 8
                 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0; % 9
                 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0; % 10
                 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0; % 11
                 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0; % 12
                 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0; % 13
                 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0; % 14
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0; % 15
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1; % 16
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1; % 17
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1; % 18
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 1; % 19
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1; % 20
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1; % 21
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 1; % 22
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 1; % 23
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1; % 24
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 1; % 25
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 1;]; % 26

%                1 2 3 4 5
matrixHammingDec = [1 0 0 0 0; % 1
                    0 1 0 0 0; % 2
                    1 1 0 0 0; % 3
                    0 0 1 0 0; % 4
                    1 0 1 0 0; % 5
                    0 1 1 0 0; % 6
                    1 1 1 0 0; % 7
                    0 0 0 1 0; % 8
                    1 0 0 1 0; % 9
                    0 1 0 1 0; % 10
                    1 1 0 1 0; % 11
                    0 0 1 1 0; % 12
                    1 0 1 1 0; % 13
                    0 1 1 1 0; % 14
                    1 1 1 1 0; % 15
                    0 0 0 0 1; % 16
                    1 0 0 0 1; % 17
                    0 1 0 0 1; % 18
                    1 1 0 0 1; % 19
                    0 0 1 0 1; % 20
                    1 0 1 0 1; % 21
                    0 1 1 0 1; % 22
                    1 1 1 0 1; % 23
                    0 0 0 1 1; % 24
                    1 0 0 1 1; % 25
                    0 1 0 1 1; % 26
                    % % % % %
                    1 0 0 0 0; % 27
                    0 1 0 0 0; % 28
                    0 0 1 0 0; % 29
                    0 0 0 1 0; % 30
                    0 0 0 0 1];% 31
 
r = length(gX) - 1;
n = k + r + 5;
K = 2^k;

Ncur = 0;
Nt = 0;

PeBit = 0;
PED = 0;

%     Источник
indexCode = randi([1 K],1,1);%генерация индекса код. слова

while Ncur < N
    %     CRC-r
    mX = codes(indexCode, :); % берём код. слово по индексу из код. книжки
    
    %     Hamming Encoder
    extended_mX = [0, 0, mX]; % добавляем два бита в начало
    extended_mH = HammingEncoder(matrixHammingEnc, extended_mX);    
    mH = extended_mH(3:1:end); % удаляем два бита в начале
    
    %     BPSK
    mS = mH.*-2 + 1;
    
    %     АБГШ
    mR = mS + sigma * randn(1, n);
    
    %     BPSK ^-1
    mX_ = mR < 0;
    
    %     Hamming Decoder
    extended_mX_ = [0, 0, mX_]; % добавляем два бита в начало
    extended_mH_ = HammingDecoder(matrixHammingDec, extended_mX_);
    mH_ = extended_mH_(3:1:end); % удаляем два бита в начале
    
    %     CRC-r ^-1    
    flagCRC = sum(modGx(mH_, gX));
    flagSum = sum(xor(mH_, mX));
    
    if flagCRC == 0 % ошибки нет или не обнаружена
        PED = PED + (flagSum > 0 & flagCRC == 0);
        indexCode = randi([1 K],1,1);%генерация индекса код. слова
        Ncur = Ncur + 1;
        if mod(Ncur, 5000) == 0
            disp(Ncur);
        end
    end
    
    PeBit = PeBit + flagSum;
    Nt = Nt + 1;
end

PeBit = PeBit / Nt / n;
PED = PED / Nt;
T = (k * N) / (n * Nt);